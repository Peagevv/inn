<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlayDual simulaci칩n - Industria alimentaria</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #instructions {
            color: white;
            text-align: center;
            max-width: 600px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        #instructions button {
            display: block;
            margin: 30px auto 0 auto;
            /* margen superior y centrado */
            padding: 10px 25px;
            font-size: 16px;
            background-color: #202021;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }


        #instructions button:hover {
            background: linear-gradient(to right, rgb(132, 165, 218), rgba(21, 31, 222, 0.5));
        }

        #stats {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 100;
        }

        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 300;
        }

        #loadingProgress {
            width: 300px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        #loadingBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, rgb(132, 165, 218), rgba(21, 31, 222, 0.5));
            transition: width 0.3s;
        }



        /* Estilos para el sistema de di치logos */
        #dialogContainer {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            z-index: 500;
        }

        #dialogContainer>div {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #3A86FF;
            border-radius: 10px;
            padding: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            max-height: 60vh;
            overflow-y: auto;
        }

        #speakerName {
            font-weight: bold;
            color: #ada9e6;
            margin-bottom: 10px;
        }

        #dialogText {
            margin-bottom: 15px;
            line-height: 1.4;
            animation: typewriter 0.05s steps(1) infinite;
        }

        #dialogOptions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dialog-option {
            padding: 10px;
            background: rgba(30, 23, 19, 0.5);
            border: 1px solid #2D3748;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: left;
        }

        .dialog-option:hover {
            background: linear-gradient(to right, rgba(59, 131, 246, 0.383), rgba(222, 21, 209, 0.5));
        }

        #continueButton {
            margin-top: 15px;
            padding: 8px 15px;
            background: #4a5057;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }

        #continueButton:hover {
            background: linear-gradient(to right, rgba(59, 131, 246, 0.383), rgba(222, 21, 209, 0.5));
        }

        @keyframes typewriter {
            from {
                opacity: 0.8;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>
<!-- Agrega esto justo antes del cierre del body -->
<audio id="dialogSound" preload="auto">
    <source src="m.e.mp3" type="audio/mpeg">
    <!-- Cambia dialog_click.mp3 por tu archivo de sonido -->
</audio>

<body>
    <div id="stats"></div>
    <div id="info">VR Study Room - Haz clic para comenzar</div>
    <div id="blocker">
        <div id="instructions">
            <h1>PlayDual</h1>
            <p>Conquista el juego, domina el desaf칤o.</p>
            <p>Controles:</p>
            <ul style="text-align: left; display: inline-block;">
                <li>WASD: Movimiento</li>
                <li>Rat칩n: Mirar alrededor</li>
                <li>Click izquierdo: Activar controles</li>
                <li>ESC: Salir de los controles</li>
                <li>R: Reiniciar posici칩n</li>
                <li>E: Interactuar</li>
            </ul>
            <button id="startButton">Comenzar Experiencia</button>
        </div>
    </div>
    <div id="loadingScreen">
        <div class="spinner"></div>
        <h2 style="color: white; margin-top: 20px;">Cargando modelo 3D...</h2>
        <div id="loadingProgress">
            <div id="loadingBar"></div>
        </div>

    </div>
    <!-- Sistema de di치logos -->
    <div id="dialogContainer">
        <div>
            <div id="speakerName">LOUISE</div>
            <div id="dialogText"></div>
            <div id="dialogOptions"></div>
            <button id="continueButton">Continuar</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
    <script>
        // Variables globales optimizadas
        let camera, scene, renderer, controls, model, stats;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();
        let rafId;
        let lastRenderTime = 0;
        const targetFPS = 60;
        let needsShadowUpdate = false;
        let mixer;
        let idleAction, talking1Action, talking2Action;
        let currentAction;
        const clock = new THREE.Clock();

        // Configuraci칩n de rendimiento
        const MOVEMENT_SPEED = 2.0;
        const JUMP_FORCE = 8.0;
        const FRICTION = .8;
        const GRAVITY = 0.2;

        // Posici칩n por defecto del jugador
        const defaultPlayerPosition = new THREE.Vector3(2, 1.8, 3);

        // Variables para el sistema de di치logos
        let currentDialogTree = null;
        let currentDialogNode = null;
        let isDialogTyping = false;
        let fullDialogText = '';
        let dialogTimeout = null;
        let isNearLouise = false;
        let hasStartedDialog = false;
        const DIALOG_TRIGGER_DISTANCE = 3.0;
        let currentTextPart = 0;
        let dialogTextParts = [];

        // Definici칩n de di치logos profesionales
        const dialogs = {
            start: {
                text: "춰Hola! Bienvenido a PlayDual L치cteos, el lugar donde el queso no solo se produce... 춰tambi칠n se aprende! 游\n\nSoy Louise, secretaria de planta. Aqu칤 podr치s explorar c칩mo funciona una planta real de producci칩n de quesos, conocer치s nuestras 치reas clave y, si est치s aplicando a una vacante, te haremos algunas preguntas para ver qu칠 tan afinado est치 tu perfil.\n\nDime, 쯤u칠 te gustar칤a hacer hoy?",
                options: [
                    { text: "Me interesa conocer como funciona la planta", next: "func_planta" },
                    { text: "Estoy aplicando para un puesto como ingeniero industrial.", next: "entrevista" },
                    { text: "Solo estoy explorando por inter칠s general..", next: "greeting" }
                ],
                character: "LOUISE"
            },
            func_planta: {
                text: "춰Perfecto! Antes de dejarte pasar al 치rea de producci칩n, necesito saber si tienes algunas nociones b치sicas del trabajo que realizamos aqu칤. Te har칠 unas preguntas r치pidas. No te preocupes, es solo para conocer tu nivel de familiaridad.",
                options: [
                    { text: "춰De acuerdo, estoy listo!", next: "start_a" },
                    { text: "Creo que necesito estudiar un poco m치s...", next: "insecure_a" }
                ],
                character: "LOUISE"
            },
            start_a: {
                text: "쮺u치l crees que es la funci칩n principal de un ingeniero industrial en una planta de producci칩n?",
                options: [
                    {
                        text: "Aplicar m칠todos cuantitativos y herramientas de an치lisis para mejorar continuamente los procesos, reduciendo tiempos, costos y desperdicios sin comprometer la calidad del producto final.",
                        next: "correct1"
                    },
                    {
                        text: "Implementar 칰nicamente sistemas de mantenimiento correctivo y supervisar directamente la operaci칩n de maquinaria en cada turno.",
                        next: "incorrect1"
                    },
                    {
                        text: "Dise침ar exclusivamente los protocolos de control microbiol칩gico y f칤sico-qu칤mico en productos l치cteos, cumpliendo con normativas sanitarias internacionales.",
                        next: "incorrect1"
                    }
                ],
                character: "LOUISE"
            },
            correct1: {
                text: "춰Correcto! Esa es una descripci칩n precisa del rol del ingeniero industrial. Has demostrado tener una buena base.",
                options: [
                    { text: "Continuar con la siguiente pregunta", next: "next_question_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            incorrect1: {
                text: "No es del todo correcto. Esa funci칩n corresponde a otro perfil profesional. No te preocupes, puedes intentarlo de nuevo o seguir explorando.",
                options: [
                    { text: "Intentar de nuevo", next: "start_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            next_question_a: {
                text: "Excelente, ahora vamos con la siguiente pregunta. 쯈u칠 herramientas consideras esenciales para un ingeniero industrial en una planta de producci칩n?",
                options: [
                    {
                        text: "Sistemas de ejecuci칩n de manufactura (MES), herramientas de an치lisis estad칤stico como Minitab, simuladores de procesos (Arena, FlexSim) y enfoques de mejora como Lean Six Sigma.",
                        next: "correct2"
                    },
                    {
                        text: "Planos en AutoCAD, software de edici칩n de im치genes, y herramientas ofim치ticas como Excel y PowerPoint.",
                        next: "incorrect2"
                    },
                    {
                        text: "Sistemas de control num칠rico (CNC) sin integraci칩n con sistemas de gesti칩n de calidad o procesos de mejora continua.",
                        next: "incorrect2"
                    }
                ],
                character: "LOUISE"
            },
            incorrect2: {
                text: "Esa respuesta es demasiado b치sica y no refleja las herramientas avanzadas que un ingeniero industrial debe manejar. Intenta pensar en metodolog칤as y tecnolog칤as m치s espec칤ficas para la optimizaci칩n de procesos.",
                options: [
                    { text: "Intentar de nuevo", next: "next_question_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            correct2: {
                text: "춰Muy bien! Has identificado las herramientas clave que un ingeniero industrial debe dominar para optimizar procesos y mejorar la eficiencia en la planta.",
                options: [
                    { text: "Continuar con la siguiente pregunta", next: "next_question_b" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            next_question_b: {
                text: "Ahora, una pregunta m치s. Ante un escenario sostenido de ineficiencia en una l칤nea de producci칩n automatizada, 쯖u치l ser칤a el enfoque m치s robusto y estructurado para diagnosticar y mitigar la causa ra칤z del problema?",
                options: [
                    {
                        text: "Aplicar mantenimiento aut칩nomo bajo los principios de TPM, revisar los hist칩ricos de OEE, e implementar planes de acci칩n correctiva para las estaciones con mayor variabilidad en los tiempos de ciclo.",
                        next: "incorrect3aa"
                    },
                    {
                        text: "Implementar un enfoque basado en datos mediante la recopilaci칩n de KPIs en tiempo real a trav칠s de sensores IoT, realizar un an치lisis estad칤stico multivariable con herramientas como Minitab o Python, identificar cuellos de botella con mapas de flujo de valor (VSM), y aplicar DMAIC de Six Sigma para ejecutar soluciones sostenibles.",
                        next: "correctl"
                    },
                    {
                        text: "Utilizar herramientas de control estad칤stico de procesos (SPC) para monitorear variaciones, aplicar Kaizen para peque침as mejoras continuas y reforzar la formaci칩n del personal operativo en pr치cticas estandarizadas.",
                        next: "incorrect3ab"
                    }
                ],
                character: "LOUISE"
            },
            correctl: {
                text: "춰Correcto! Has demostrado un buen entendimiento de las metodolog칤as y herramientas necesarias para abordar problemas complejos en la producci칩n.",
                text: " Tu perfil parece alinearse con lo que buscamos.",
                text: " 쯊e gustar칤a explorar m치s sobre la planta o prefieres conocer m치s sobre la oficina?",
                options: [
                    { text: " Explorar la planta", next: "explorar_planta" },
                    { text: "Explorar la oficia", next: "explorar_off" }
                ],
                character: "LOUISE"
            },

            incorrect3aa: {
                text: "Esa estrategia aborda s칤ntomas, pero no ataca la ra칤z del problema. Aunque TPM y OEE son 칰tiles, no se integran con tecnolog칤as emergentes ni con an치lisis predictivo en tiempo real. Intenta pensar en un enfoque m치s integral, que combine herramientas estad칤sticas avanzadas con metodolog칤as estructuradas como DMAIC y tecnolog칤as IoT.",
                options: [
                    { text: "Intentar de nuevo", next: "fabrica_1" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            incorrect3ab: {
                text: "Buena intenci칩n, pero limitada. Estas acciones ayudan a estabilizar procesos, pero no garantizan un an치lisis profundo de las causas ra칤z ni aprovechan datos en tiempo real para una mejora sostenible. Busca un enfoque m치s hol칤stico, apoyado en datos y tecnolog칤a avanzada.",
                options: [
                    { text: "Intentar de nuevo", next: "next_question_b" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },

            greeting: {
                text: "춰Qu칠 amable! Si necesitas algo, aqu칤 estar칠. Buen d칤a.",
                options: [],
                character: "LOUISE"
            },
            end_helpful: {
                text: "Perfecto. No dudes en preguntar si necesitas algo m치s. Estoy aqu칤 para ayudar.",
                options: [],
                character: "LOUISE"
            },
            entrevista: {
                text: "Version beta en desarrollo. Por favor, vuelve m치s tarde.",
                character: "LOUISE"
            },

        };

        // Inicializaci칩n optimizada
        function init() {
            // Configuraci칩n de estad칤sticas de rendimiento
            stats = new Stats();
            stats.showPanel(0);
            document.getElementById('stats').appendChild(stats.dom);

            // Configuraci칩n de Three.js optimizada
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Configuraci칩n de renderizador optimizada
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                powerPreference: "high-performance",
                logarithmicDepthBuffer: true,
                precision: 'mediump'
            });
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false;
            document.body.appendChild(renderer.domElement);

            // Controles PointerLock optimizados
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // Resetear posici칩n
            resetPlayerPosition();

            // Configuraci칩n de eventos optimizada
            setupUI();
            setupEventListeners();
            setupDialogSystem();
            setupInteraction();

            // Configuraci칩n de luces optimizada
            setupLights();
        }

        function setupUI() {
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                // Mostrar pantalla de carga al hacer clic en comenzar
                document.getElementById('loadingScreen').style.display = 'flex';
                document.getElementById('instructions').style.display = 'none';

                // Iniciar la carga del modelo despu칠s de un breve retraso para que se muestre la pantalla de carga
                setTimeout(() => {
                    controls.lock();
                    loadModel();
                }, 100);
            });

            controls.addEventListener('lock', () => {
                document.getElementById('blocker').style.display = 'none';
                needsShadowUpdate = true;
            });

            controls.addEventListener('unlock', () => {
                // solo se mostrara el bloqueador si no estamos en un dialogo
                if (!hasStartedDialog) {
                    document.getElementById('blocker').style.display = 'flex';
                    document.getElementById('instructions').style.display = '';
                }
                document.getElementById('loadingScreen').style.display = 'none';
            });
        }

        function setupEventListeners() {
            // Eventos de teclado optimizados
            const keyHandler = (e, state) => {
                switch (e.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = state; break;
                    case 'ArrowRight': case 'KeyA': moveRight = state; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = state; break;
                    case 'ArrowLeft': case 'KeyD': moveLeft = state; break;
                    case 'Space': if (state && canJump) { velocity.y = JUMP_FORCE; canJump = false; needsShadowUpdate = true; } break;
                    case 'KeyR': if (state) { resetPlayerPosition(); needsShadowUpdate = true; } break;
                    case 'KeyE': if (state && isNearLouise && !hasStartedDialog) {
                        hasStartedDialog = true;
                        startDialog(dialogs);
                    } break;
                }
            };

            document.addEventListener('keydown', (e) => keyHandler(e, true), { passive: true });
            document.addEventListener('keyup', (e) => keyHandler(e, false), { passive: true });
            window.addEventListener('resize', onWindowResize, { passive: true });
        }

        function loadModel() {
            const loader = new THREE.GLTFLoader();

            // Mostrar progreso de carga
            loader.load(
                'Office 14_1.glb',
                (gltf) => {
                    model = gltf.scene;

                    // Optimizaci칩n del modelo
                    model.traverse((obj) => {
                        if (obj.isMesh) {
                            // Configuraciones de rendimiento
                            obj.castShadow = false; // Solo activar en objetos importantes
                            obj.receiveShadow = true;
                            obj.frustumCulled = true;

                            // Optimizar material
                            obj.material = optimizeMaterial(obj.material);
                        }
                    });

                    scene.add(model);
                    console.log('Modelo cargado y optimizado');
                    loadCharacter(); // Cargar el modelo FBX despu칠s de cargar el GLB

                    // Ocultar pantalla de carga cuando el modelo est칠 listo
                    document.getElementById('loadingScreen').style.display = 'none';
                },
                // Funci칩n de progreso
                (xhr) => {
                    const percentLoaded = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('loadingBar').style.width = `${percentLoaded}%`;
                    console.log(`${percentLoaded.toFixed(2)}% cargado`);
                },
                // Funci칩n de error
                (error) => {
                    console.error('Error al cargar el modelo:', error);
                    document.getElementById('loadingScreen').style.display = 'none';
                    alert('Error al cargar el modelo. Por favor recarga la p치gina.');
                }
            );
        }

        // Funci칩n para cargar el modelo FBX Louise
        function loadCharacter() {
            const loader = new THREE.FBXLoader();

            loader.load(
                'louise/Idle.fbx',  // Usa solo un archivo FBX
                (fbx) => {
                    // Primero verifica si Louise ya existe en la escena
                    const existingLouise = scene.getObjectByName('Louise');
                    if (existingLouise) {
                        scene.remove(existingLouise); // Elimina el duplicado si existe
                    }

                    const character = fbx;
                    character.position.set(-3, 0, 5);
                    character.scale.set(.012, .012, .012);
                    character.rotation.y = Math.PI;
                    character.name = 'Louise'; // Nombre 칰nico para referencia

                    character.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                            obj.material = optimizeMaterial(obj.material);
                        }
                    });

                    // Configuraci칩n de animaciones (solo con el archivo Idle)
                    if (fbx.animations && fbx.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        idleAction = mixer.clipAction(fbx.animations[0]);
                        idleAction.setLoop(THREE.LoopRepeat);
                        idleAction.play();
                        currentAction = idleAction;
                    }

                    scene.add(character);
                    console.log('Personaje FBX cargado correctamente');
                    document.getElementById('loadingScreen').style.display = 'none';
                },
                (xhr) => {
                    const percentLoaded = 50 + (xhr.loaded / xhr.total) * 50;
                    document.getElementById('loadingBar').style.width = `${percentLoaded}%`;
                },
                (error) => {
                    console.error('Error al cargar el personaje:', error);
                    document.getElementById('loadingScreen').style.display = 'none';
                }
            );
        }

        // Funci칩n para calcular distancia a Louise
        function getDistanceToLouise() {
            const louise = scene.getObjectByName('Louise');
            if (!louise || !controls.getObject()) return Infinity;

            const playerPosition = controls.getObject().position;
            const louisePosition = louise.position;

            return playerPosition.distanceTo(louisePosition);
        }

        function optimizeMaterial(material) {
            // Configuraci칩n de materiales para mejor rendimiento
            if (material instanceof THREE.MeshStandardMaterial) {
                material.roughness = 0.8;
                material.metalness = 0.2;
            }
            material.side = THREE.FrontSide;
            material.flatShading = false;
            return material;
        }

        function setupLights() {
            scene.background = new THREE.Color(0xFFFFFF);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Luces optimizadas
            const ambientLight = new THREE.AmbientLight(0xFFFFFFF, .5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffe5b4, 0.3);
            directionalLight.position.set(3, 10, 5).normalize();
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffe5b4, 0.3, 50);
            pointLight.position.set(0, 1, 0);
            scene.add(pointLight);

            // Luces de rebote para paredes (posici칩nalas seg칰n tu escena)
            const wallLight1 = new THREE.DirectionalLight(0xFFF5E6, 0.4);
            wallLight1.position.set(-5, 2, 0); // Pared izquierda
            wallLight1.castShadow = false; // No necesitan sombras
            scene.add(wallLight1);

            const wallLight2 = new THREE.DirectionalLight(0xFFF5E6, 0.4);
            wallLight2.position.set(5, 2, 0); // Pared derecha
            scene.add(wallLight2);

            // Luz desde el techo (para iluminaci칩n difusa)
            const ceilingLight = new THREE.RectAreaLight(0xFFFFFF, 0.3, 10, 10);
            ceilingLight.position.set(0, 5, 0);
            ceilingLight.rotation.x = Math.PI; // Apunta hacia abajo
            scene.add(ceilingLight);
        }

        function resetPlayerPosition() {
            if (controls && controls.getObject) {
                controls.getObject().position.copy(defaultPlayerPosition);
                velocity.set(0, 0, 0);
                canJump = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            needsShadowUpdate = true;
        }

        // Bucle de animaci칩n optimizado
        function animate(currentTime) {
            stats.begin();
            rafId = requestAnimationFrame(animate);

            // Control de FPS
            const deltaTime = currentTime - lastRenderTime;
            const targetDelta = 1000 / targetFPS;

            if (deltaTime < targetDelta) {
                stats.end();
                return;
            }

            lastRenderTime = currentTime - (deltaTime % targetDelta);
            const clampedDeltaTime = Math.min(0.1, deltaTime / 1000);

            // Actualizar animaciones si el mixer existe
            if (mixer) {
                mixer.update(clampedDeltaTime);
            }

            if (controls && controls.isLocked) {
                updatePlayerMovement(clampedDeltaTime);
                applyGravity(clampedDeltaTime);
            }

            // Actualizar sombras solo cuando sea necesario
            if (needsShadowUpdate) {
                renderer.shadowMap.needsUpdate = true;
                needsShadowUpdate = false;
            }

            renderer.render(scene, camera);
            stats.end();
        }

        function updatePlayerMovement(deltaTime) {
            velocity.x *= FRICTION;
            velocity.z *= FRICTION;

            direction.set(0, 0, 0);
            if (moveForward) direction.z -= 1;
            if (moveBackward) direction.z += 1;
            if (moveLeft) direction.x -= 1;
            if (moveRight) direction.x += 1;

            if (direction.length() > 0) {
                direction.normalize();
                velocity.x += direction.x * MOVEMENT_SPEED * deltaTime * 10;
                velocity.z += direction.z * MOVEMENT_SPEED * deltaTime * 10;
                needsShadowUpdate = true;
            }

            controls.moveRight(-velocity.x * deltaTime);
            controls.moveForward(-velocity.z * deltaTime);
        }

        function applyGravity(deltaTime) {
            velocity.y -= GRAVITY * deltaTime * 10;
            controls.getObject().position.y += velocity.y * deltaTime;

            if (controls.getObject().position.y < defaultPlayerPosition.y) {
                controls.getObject().position.y = defaultPlayerPosition.y;
                velocity.y = 0;
                canJump = true;
                needsShadowUpdate = true;
            }
        }

        /***********************/
        /* SISTEMA DE DI츼LOGOS */
        /***********************/

        function setupDialogSystem() {
            // Evento para continuar
            document.getElementById('continueButton').addEventListener('click', () => {
                if (isDialogTyping) {
                    finishTyping();
                    return;
                }

                // Si hay m치s partes de texto por mostrar
                if (currentTextPart < dialogTextParts.length - 1) {
                    currentTextPart++;
                    showTextPart(dialogTextParts[currentTextPart]);
                } else {
                    // Si no hay m치s partes, mostrar opciones o cerrar di치logo
                    if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                        showDialogOptions();
                    } else {
                        endDialog();
                    }
                }
            });
        }

        function setupInteraction() {
            // Verificar proximidad en el bucle de animaci칩n
            function checkProximity() {
                const distance = getDistanceToLouise();

                if (distance <= DIALOG_TRIGGER_DISTANCE) {
                    if (!isNearLouise) {
                        isNearLouise = true;
                        // Mostrar indicador visual
                        document.getElementById('info').textContent = "Presiona E para hablar con Louise";
                    }
                } else {
                    if (isNearLouise) {
                        isNearLouise = false;
                        document.getElementById('info').textContent = "VR Study Room";

                        // Si el jugador se aleja durante el di치logo
                        if (hasStartedDialog) {
                            endDialog();
                            hasStartedDialog = false;
                        }
                    }
                }
            }

            // A침adir la verificaci칩n al bucle de animaci칩n
            const originalAnimate = animate;
            animate = function (currentTime) {
                originalAnimate(currentTime);
                if (controls.isLocked) {
                    checkProximity();
                }
            };
        }

        // Funci칩n para iniciar un di치logo
        function startDialog(dialogTree) {
            // Pausar controles
            controls.unlock();
            // Ocultar el bloqueador de instrucciones
            document.getElementById('blocker').style.display = 'none';

            // Mostrar contenedor de di치logo
            const dialogContainer = document.getElementById('dialogContainer');
            dialogContainer.style.display = 'block';

            // Configurar di치logo inicial
            currentDialogTree = dialogTree;
            showDialogNode('start');
        }

        // Funci칩n para mostrar un nodo de di치logo espec칤fico
        function showDialogNode(nodeId) {
            const node = dialogs[nodeId];
            if (!node) return endDialog();

            currentDialogNode = node;
            document.getElementById('speakerName').textContent = node.character || 'LOUISE';

            // Cambiar a animaci칩n de hablar
            if (mixer && talking1Action) {
                if (currentAction) currentAction.stop();
                talking1Action.reset().play();
                currentAction = talking1Action;
            }

            // Dividir el texto en partes
            splitDialogText(node.text);

            // Mostrar la primera parte del texto
            currentTextPart = 0;
            showTextPart(dialogTextParts[currentTextPart]);

            // Ocultar opciones inicialmente (se mostrar치n al final del texto completo)
            document.getElementById('dialogOptions').innerHTML = '';
            document.getElementById('continueButton').style.display = 'none';
        }

        // Dividir el texto del di치logo en partes m치s peque침as
        function splitDialogText(text) {
            const maxCharsPerPart = 200; // N칰mero m치ximo de caracteres por parte
            dialogTextParts = [];

            // Si el texto es m치s corto que el m치ximo, usarlo completo
            if (text.length <= maxCharsPerPart) {
                dialogTextParts.push(text);
                return;
            }

            // Dividir en p치rrafos primero (basado en saltos de l칤nea)
            const paragraphs = text.split('\n\n');

            for (const paragraph of paragraphs) {
                // Si el p치rrafo es demasiado largo, dividirlo en oraciones
                if (paragraph.length > maxCharsPerPart) {
                    const sentences = paragraph.split(/(?<=[.!?])\s+/);
                    let currentPart = '';

                    for (const sentence of sentences) {
                        if (currentPart.length + sentence.length > maxCharsPerPart && currentPart.length > 0) {
                            dialogTextParts.push(currentPart.trim());
                            currentPart = sentence;
                        } else {
                            currentPart += (currentPart.length > 0 ? ' ' : '') + sentence;
                        }
                    }

                    if (currentPart.length > 0) {
                        dialogTextParts.push(currentPart.trim());
                    }
                } else {
                    dialogTextParts.push(paragraph);
                }
            }
        }

        // Mostrar una parte espec칤fica del texto del di치logo
      function showTextPart(part) {
    isDialogTyping = true;
    const dialogElement = document.getElementById('dialogText');
    dialogElement.textContent = '';
    const dialogSound = document.getElementById('dialogSound');
    
    // Configurar el sonido
    dialogSound.volume = 0.3; // Ajusta el volumen seg칰n necesites
    let soundTimeout;

    // Iniciar animaci칩n de hablar
    if (mixer && talking1Action) {
        if (currentAction) currentAction.stop();
        talking1Action.reset().play();
        currentAction = talking1Action;
    }

    let currentIndex = 0;
    const typingInterval = setInterval(() => {
        if (currentIndex < part.length) {
            dialogElement.textContent += part[currentIndex];
            currentIndex++;
            
            // Reproducir sonido solo para caracteres visibles (no espacios)
            if (part[currentIndex-1] !== ' ' && part[currentIndex-1] !== '\n') {
                // Detener cualquier sonido previo
                dialogSound.pause();
                dialogSound.currentTime = 0;
                
                // Reproducir el sonido
                dialogSound.play().catch(e => console.log("No se pudo reproducir sonido:", e));
            }
        } else {
            clearInterval(typingInterval);
            clearTimeout(soundTimeout);
            isDialogTyping = false;

            // Mostrar bot칩n "Continuar" si hay m치s partes
            if (currentTextPart < dialogTextParts.length - 1) {
                document.getElementById('continueButton').style.display = 'block';
                document.getElementById('continueButton').textContent = 'Continuar';
            }
            // Si es la 칰ltima parte, mostrar opciones o bot칩n "Cerrar"
            else {
                if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                    showDialogOptions();
                } else {
                    document.getElementById('continueButton').style.display = 'block';
                    document.getElementById('continueButton').textContent = 'Cerrar';
                }

                // Volver a animaci칩n Idle cuando termina de hablar
                if (mixer && idleAction) {
                    if (currentAction) currentAction.stop();
                    idleAction.reset().play();
                    currentAction = idleAction;
                }
            }
        }
    }, 30); // Velocidad de escritura (ajusta seg칰n necesites)
}

        // Mostrar las opciones de di치logo
        function showDialogOptions() {
            const optionsContainer = document.getElementById('dialogOptions');
            optionsContainer.innerHTML = '';

            if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                currentDialogNode.options.forEach(option => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'dialog-option';
                    optionElement.textContent = option.text;
                    optionElement.addEventListener('click', () => {
                        showDialogNode(option.next);
                    });
                    optionsContainer.appendChild(optionElement);
                });
                document.getElementById('continueButton').style.display = 'none';
            }
        }

        // Saltar el efecto de escritura
function finishTyping() {
    clearTimeout(dialogTimeout);
    document.getElementById('dialogText').textContent = dialogTextParts[currentTextPart];
    isDialogTyping = false;
    
    // Detener el sonido
    const dialogSound = document.getElementById('dialogSound');
    dialogSound.pause();
    dialogSound.currentTime = 0;

    // Mostrar bot칩n "Continuar" si hay m치s partes
    if (currentTextPart < dialogTextParts.length - 1) {
        document.getElementById('continueButton').style.display = 'block';
        document.getElementById('continueButton').textContent = 'Continuar';
    }
    // Si es la 칰ltima parte, mostrar opciones o bot칩n "Cerrar"
    else {
        if (currentDialogNode.options && currentDialogNode.options.length > 0) {
            showDialogOptions();
        } else {
            document.getElementById('continueButton').style.display = 'block';
            document.getElementById('continueButton').textContent = 'Cerrar';
        }
    }

    // Volver a animaci칩n Idle cuando se fuerza el texto
    if (mixer && idleAction) {
        if (currentAction) currentAction.stop();
        idleAction.reset().play();
        currentAction = idleAction;
    }
}

        // Finalizar di치logo
      function endDialog() {
    document.getElementById('dialogContainer').style.display = 'none';
    hasStartedDialog = false;
    
    // Detener el sonido
    const dialogSound = document.getElementById('dialogSound');
    dialogSound.pause();
    dialogSound.currentTime = 0;

    // Asegurarse de volver a la animaci칩n Idle
    if (mixer && idleAction) {
        if (currentAction) currentAction.stop();
        idleAction.reset().play();
        currentAction = idleAction;
    }
    document.getElementById('blocker').style.display = 'none';
    // Intentar reactivar los controles
    try {
        controls.lock();
    } catch (e) {
        console.log("Los controles ya est치n activos o no se pueden bloquear:", e);
    }

    if (getDistanceToLouise() > DIALOG_TRIGGER_DISTANCE) {
        controls.lock();
    }
}

        // Inicializaci칩n controlada
        document.addEventListener('DOMContentLoaded', () => {
            init();
            animate(performance.now());
        });

        // Limpieza al salir
        window.addEventListener('beforeunload', () => {
            cancelAnimationFrame(rafId);
            if (renderer) renderer.dispose();
            if (stats) stats.dom.remove();
        });
    </script>
</body>

</html>