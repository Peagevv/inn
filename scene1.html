<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlayDual simulaci√≥n - Industria alimentaria</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            z-index: 100;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #instructions {
            color: white;
            text-align: center;
            max-width: 600px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        #instructions button {
            display: block;
            margin: 30px auto 0 auto;
            /* margen superior y centrado */
            padding: 10px 25px;
            font-size: 16px;
            background-color: #202021;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }


        #instructions button:hover {
            background: linear-gradient(to right, rgb(132, 165, 218), rgba(21, 31, 222, 0.5));
        }

        #stats {
            position: absolute;
            left: 0;
            top: 0;
            z-index: 100;
        }

        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 300;
        }

        #loadingProgress {
            width: 300px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        #loadingBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, rgb(132, 165, 218), rgba(21, 31, 222, 0.5));
            transition: width 0.3s;
        }



        /* Estilos para el sistema de di√°logos */
        #dialogContainer {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            z-index: 500;
        }

        #dialogContainer>div {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #3A86FF;
            border-radius: 10px;
            padding: 20px;
            color: white;
            font-family: 'Courier New', monospace;
            max-height: 60vh;
            overflow-y: auto;
        }

        #speakerName {
            font-weight: bold;
            color: #ada9e6;
            margin-bottom: 10px;
        }

        #dialogText {
            margin-bottom: 15px;
            line-height: 1.4;
            animation: typewriter 0.05s steps(1) infinite;
        }

        #dialogOptions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dialog-option {
            padding: 10px;
            background: rgba(30, 23, 19, 0.5);
            border: 1px solid #2D3748;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: left;
        }

        .dialog-option:hover {
            background: linear-gradient(to right, rgba(59, 131, 246, 0.383), rgba(222, 21, 209, 0.5));
        }

        #continueButton {
            margin-top: 15px;
            padding: 8px 15px;
            background: #4a5057;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }

        #continueButton:hover {
            background: linear-gradient(to right, rgba(59, 131, 246, 0.383), rgba(222, 21, 209, 0.5));
        }

        @keyframes typewriter {
            from {
                opacity: 0.8;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>
<!-- Agrega esto justo antes del cierre del body -->
<audio id="dialogSound" preload="auto">
    <source src="m.e.mp3" type="audio/mpeg">
    <!-- Cambia dialog_click.mp3 por tu archivo de sonido -->
</audio>

<body>
    <div id="stats"></div>
    <div id="info">VR Study Room - Haz clic para comenzar</div>
    <div id="blocker">
        <div id="instructions">
            <h1>PlayDual</h1>
            <p>Conquista el juego, domina el desaf√≠o.</p>
            <p>Controles:</p>
            <ul style="text-align: left; display: inline-block;">
                <li>WASD: Movimiento</li>
                <li>Rat√≥n: Mirar alrededor</li>
                <li>Click izquierdo: Activar controles</li>
                <li>ESC: Salir de los controles</li>
                <li>R: Reiniciar posici√≥n</li>
                <li>E: Interactuar</li>
            </ul>
            <button id="startButton">Comenzar Experiencia</button>
        </div>
    </div>
    <div id="loadingScreen">
        <div class="spinner"></div>
        <h2 style="color: white; margin-top: 20px;">Cargando modelo 3D...</h2>
        <div id="loadingProgress">
            <div id="loadingBar"></div>
        </div>

    </div>
    <!-- Sistema de di√°logos -->
    <div id="dialogContainer">
        <div>
            <div id="speakerName">LOUISE</div>
            <div id="dialogText"></div>
            <div id="dialogOptions"></div>
            <button id="continueButton">Continuar</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.min.js"></script>
    <script>
        // Variables globales optimizadas
        let camera, scene, renderer, controls, model, stats;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();
        let rafId;
        let lastRenderTime = 0;
        const targetFPS = 60;
        let needsShadowUpdate = false;
        let mixer;
        let idleAction, talking1Action, talking2Action;
        let currentAction;
        const clock = new THREE.Clock();

        // Configuraci√≥n de rendimiento
        const MOVEMENT_SPEED = 2.0;
        const JUMP_FORCE = 8.0;
        const FRICTION = .8;
        const GRAVITY = 0.2;

        // Posici√≥n por defecto del jugador
        const defaultPlayerPosition = new THREE.Vector3(2, 1.8, 3);

        // Variables para el sistema de di√°logos
        let currentDialogTree = null;
        let currentDialogNode = null;
        let isDialogTyping = false;
        let fullDialogText = '';
        let dialogTimeout = null;
        let isNearLouise = false;
        let hasStartedDialog = false;
        const DIALOG_TRIGGER_DISTANCE = 3.0;
        let currentTextPart = 0;
        let dialogTextParts = [];

        // Definici√≥n de di√°logos profesionales
        const dialogs = {
            start: {
                text: "¬°Hola! Bienvenido a PlayDual L√°cteos, el lugar donde el queso no solo se produce... ¬°tambi√©n se aprende! üßÄ\n\nSoy Louise, secretaria de planta. Aqu√≠ podr√°s explorar c√≥mo funciona una planta real de producci√≥n de quesos, conocer√°s nuestras √°reas clave y, si est√°s aplicando a una vacante, te haremos algunas preguntas para ver qu√© tan afinado est√° tu perfil.\n\nDime, ¬øqu√© te gustar√≠a hacer hoy?",
                options: [
                    { text: "Me interesa conocer como funciona la planta", next: "func_planta" },
                    { text: "Estoy aplicando para un puesto como ingeniero industrial.", next: "entrevista" },
                    { text: "Solo estoy explorando por inter√©s general..", next: "greeting" }
                ],
                character: "LOUISE"
            },
            func_planta: {
                text: "¬°Perfecto! Antes de dejarte pasar al √°rea de producci√≥n, necesito saber si tienes algunas nociones b√°sicas del trabajo que realizamos aqu√≠. Te har√© unas preguntas r√°pidas. No te preocupes, es solo para conocer tu nivel de familiaridad.",
                options: [
                    { text: "¬°De acuerdo, estoy listo!", next: "start_a" },
                    { text: "Creo que necesito estudiar un poco m√°s...", next: "insecure_a" }
                ],
                character: "LOUISE"
            },
            start_a: {
                text: "¬øCu√°l crees que es la funci√≥n principal de un ingeniero industrial en una planta de producci√≥n?",
                options: [
                    {
                        text: "Aplicar m√©todos cuantitativos y herramientas de an√°lisis para mejorar continuamente los procesos, reduciendo tiempos, costos y desperdicios sin comprometer la calidad del producto final.",
                        next: "correct1"
                    },
                    {
                        text: "Implementar √∫nicamente sistemas de mantenimiento correctivo y supervisar directamente la operaci√≥n de maquinaria en cada turno.",
                        next: "incorrect1"
                    },
                    {
                        text: "Dise√±ar exclusivamente los protocolos de control microbiol√≥gico y f√≠sico-qu√≠mico en productos l√°cteos, cumpliendo con normativas sanitarias internacionales.",
                        next: "incorrect1"
                    }
                ],
                character: "LOUISE"
            },
            correct1: {
                text: "¬°Correcto! Esa es una descripci√≥n precisa del rol del ingeniero industrial. Has demostrado tener una buena base.",
                options: [
                    { text: "Continuar con la siguiente pregunta", next: "next_question_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            incorrect1: {
                text: "No es del todo correcto. Esa funci√≥n corresponde a otro perfil profesional. No te preocupes, puedes intentarlo de nuevo o seguir explorando.",
                options: [
                    { text: "Intentar de nuevo", next: "start_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            next_question_a: {
                text: "Excelente, ahora vamos con la siguiente pregunta. ¬øQu√© herramientas consideras esenciales para un ingeniero industrial en una planta de producci√≥n?",
                options: [
                    {
                        text: "Sistemas de ejecuci√≥n de manufactura (MES), herramientas de an√°lisis estad√≠stico como Minitab, simuladores de procesos (Arena, FlexSim) y enfoques de mejora como Lean Six Sigma.",
                        next: "correct2"
                    },
                    {
                        text: "Planos en AutoCAD, software de edici√≥n de im√°genes, y herramientas ofim√°ticas como Excel y PowerPoint.",
                        next: "incorrect2"
                    },
                    {
                        text: "Sistemas de control num√©rico (CNC) sin integraci√≥n con sistemas de gesti√≥n de calidad o procesos de mejora continua.",
                        next: "incorrect2"
                    }
                ],
                character: "LOUISE"
            },
            incorrect2: {
                text: "Esa respuesta es demasiado b√°sica y no refleja las herramientas avanzadas que un ingeniero industrial debe manejar. Intenta pensar en metodolog√≠as y tecnolog√≠as m√°s espec√≠ficas para la optimizaci√≥n de procesos.",
                options: [
                    { text: "Intentar de nuevo", next: "next_question_a" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            correct2: {
                text: "¬°Muy bien! Has identificado las herramientas clave que un ingeniero industrial debe dominar para optimizar procesos y mejorar la eficiencia en la planta.",
                options: [
                    { text: "Continuar con la siguiente pregunta", next: "next_question_b" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            next_question_b: {
                text: "Ahora, una pregunta m√°s. Ante un escenario sostenido de ineficiencia en una l√≠nea de producci√≥n automatizada, ¬øcu√°l ser√≠a el enfoque m√°s robusto y estructurado para diagnosticar y mitigar la causa ra√≠z del problema?",
                options: [
                    {
                        text: "Aplicar mantenimiento aut√≥nomo bajo los principios de TPM, revisar los hist√≥ricos de OEE, e implementar planes de acci√≥n correctiva para las estaciones con mayor variabilidad en los tiempos de ciclo.",
                        next: "incorrect3aa"
                    },
                    {
                        text: "Implementar un enfoque basado en datos mediante la recopilaci√≥n de KPIs en tiempo real a trav√©s de sensores IoT, realizar un an√°lisis estad√≠stico multivariable con herramientas como Minitab o Python, identificar cuellos de botella con mapas de flujo de valor (VSM), y aplicar DMAIC de Six Sigma para ejecutar soluciones sostenibles.",
                        next: "correctl"
                    },
                    {
                        text: "Utilizar herramientas de control estad√≠stico de procesos (SPC) para monitorear variaciones, aplicar Kaizen para peque√±as mejoras continuas y reforzar la formaci√≥n del personal operativo en pr√°cticas estandarizadas.",
                        next: "incorrect3ab"
                    }
                ],
                character: "LOUISE"
            },
            correctl: {
                text: "¬°Correcto! Has demostrado un buen entendimiento de las metodolog√≠as y herramientas necesarias para abordar problemas complejos en la producci√≥n.",
                text: " Tu perfil parece alinearse con lo que buscamos.",
                text: " ¬øTe gustar√≠a explorar m√°s sobre la planta o prefieres conocer m√°s sobre la oficina?",
                options: [
                    { text: " Explorar la planta", next: "explorar_planta" },
                    { text: "Explorar la oficia", next: "explorar_off" }
                ],
                character: "LOUISE"
            },

            incorrect3aa: {
                text: "Esa estrategia aborda s√≠ntomas, pero no ataca la ra√≠z del problema. Aunque TPM y OEE son √∫tiles, no se integran con tecnolog√≠as emergentes ni con an√°lisis predictivo en tiempo real. Intenta pensar en un enfoque m√°s integral, que combine herramientas estad√≠sticas avanzadas con metodolog√≠as estructuradas como DMAIC y tecnolog√≠as IoT.",
                options: [
                    { text: "Intentar de nuevo", next: "fabrica_1" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },
            incorrect3ab: {
                text: "Buena intenci√≥n, pero limitada. Estas acciones ayudan a estabilizar procesos, pero no garantizan un an√°lisis profundo de las causas ra√≠z ni aprovechan datos en tiempo real para una mejora sostenible. Busca un enfoque m√°s hol√≠stico, apoyado en datos y tecnolog√≠a avanzada.",
                options: [
                    { text: "Intentar de nuevo", next: "next_question_b" },
                    { text: "Volver al inicio", next: "start" }
                ],
                character: "LOUISE"
            },

            greeting: {
                text: "¬°Qu√© amable! Si necesitas algo, aqu√≠ estar√©. Buen d√≠a.",
                options: [],
                character: "LOUISE"
            },
            end_helpful: {
                text: "Perfecto. No dudes en preguntar si necesitas algo m√°s. Estoy aqu√≠ para ayudar.",
                options: [],
                character: "LOUISE"
            },
            entrevista: {
                text: "Version beta en desarrollo. Por favor, vuelve m√°s tarde.",
                character: "LOUISE"
            },

        };

        // Inicializaci√≥n optimizada
        function init() {
            // Configuraci√≥n de estad√≠sticas de rendimiento
            stats = new Stats();
            stats.showPanel(0);
            document.getElementById('stats').appendChild(stats.dom);

            // Configuraci√≥n de Three.js optimizada
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Configuraci√≥n de renderizador optimizada
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                powerPreference: "high-performance",
                logarithmicDepthBuffer: true,
                precision: 'mediump'
            });
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false;
            document.body.appendChild(renderer.domElement);

            // Controles PointerLock optimizados
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            // Resetear posici√≥n
            resetPlayerPosition();

            // Configuraci√≥n de eventos optimizada
            setupUI();
            setupEventListeners();
            setupDialogSystem();
            setupInteraction();

            // Configuraci√≥n de luces optimizada
            setupLights();
        }

        function setupUI() {
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                // Mostrar pantalla de carga al hacer clic en comenzar
                document.getElementById('loadingScreen').style.display = 'flex';
                document.getElementById('instructions').style.display = 'none';

                // Iniciar la carga del modelo despu√©s de un breve retraso para que se muestre la pantalla de carga
                setTimeout(() => {
                    controls.lock();
                    loadModel();
                }, 100);
            });

            controls.addEventListener('lock', () => {
                document.getElementById('blocker').style.display = 'none';
                needsShadowUpdate = true;
            });

            controls.addEventListener('unlock', () => {
                // solo se mostrara el bloqueador si no estamos en un dialogo
                if (!hasStartedDialog) {
                    document.getElementById('blocker').style.display = 'flex';
                    document.getElementById('instructions').style.display = '';
                }
                document.getElementById('loadingScreen').style.display = 'none';
            });
        }

        function setupEventListeners() {
            // Eventos de teclado optimizados
            const keyHandler = (e, state) => {
                switch (e.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = state; break;
                    case 'ArrowRight': case 'KeyA': moveRight = state; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = state; break;
                    case 'ArrowLeft': case 'KeyD': moveLeft = state; break;
                    case 'Space': if (state && canJump) { velocity.y = JUMP_FORCE; canJump = false; needsShadowUpdate = true; } break;
                    case 'KeyR': if (state) { resetPlayerPosition(); needsShadowUpdate = true; } break;
                    case 'KeyE': if (state && isNearLouise && !hasStartedDialog) {
                        hasStartedDialog = true;
                        startDialog(dialogs);
                    } break;
                }
            };

            document.addEventListener('keydown', (e) => keyHandler(e, true), { passive: true });
            document.addEventListener('keyup', (e) => keyHandler(e, false), { passive: true });
            window.addEventListener('resize', onWindowResize, { passive: true });
        }

        function loadModel() {
            const loader = new THREE.GLTFLoader();

            // Mostrar progreso de carga
            loader.load(
                'Office 14_1.glb',
                (gltf) => {
                    model = gltf.scene;

                    // Optimizaci√≥n del modelo
                    model.traverse((obj) => {
                        if (obj.isMesh) {
                            // Configuraciones de rendimiento
                            obj.castShadow = false; // Solo activar en objetos importantes
                            obj.receiveShadow = true;
                            obj.frustumCulled = true;

                            // Optimizar material
                            obj.material = optimizeMaterial(obj.material);
                        }
                    });

                    scene.add(model);
                    console.log('Modelo cargado y optimizado');
                    loadCharacter(); // Cargar el modelo FBX despu√©s de cargar el GLB

                    // Ocultar pantalla de carga cuando el modelo est√© listo
                    document.getElementById('loadingScreen').style.display = 'none';
                },
                // Funci√≥n de progreso
                (xhr) => {
                    const percentLoaded = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('loadingBar').style.width = `${percentLoaded}%`;
                    console.log(`${percentLoaded.toFixed(2)}% cargado`);
                },
                // Funci√≥n de error
                (error) => {
                    console.error('Error al cargar el modelo:', error);
                    document.getElementById('loadingScreen').style.display = 'none';
                    alert('Error al cargar el modelo. Por favor recarga la p√°gina.');
                }
            );
        }

        // Funci√≥n para cargar el modelo FBX Louise
        function loadCharacter() {
            const loader = new THREE.FBXLoader();

            loader.load(
                'louise/Idle.fbx',  // Usa solo un archivo FBX
                (fbx) => {
                    // Primero verifica si Louise ya existe en la escena
                    const existingLouise = scene.getObjectByName('Louise');
                    if (existingLouise) {
                        scene.remove(existingLouise); // Elimina el duplicado si existe
                    }

                    const character = fbx;
                    character.position.set(-3, 0, 5);
                    character.scale.set(.012, .012, .012);
                    character.rotation.y = Math.PI;
                    character.name = 'Louise'; // Nombre √∫nico para referencia

                    character.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                            obj.material = optimizeMaterial(obj.material);
                        }
                    });

                    // Configuraci√≥n de animaciones (solo con el archivo Idle)
                    if (fbx.animations && fbx.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        idleAction = mixer.clipAction(fbx.animations[0]);
                        idleAction.setLoop(THREE.LoopRepeat);
                        idleAction.play();
                        currentAction = idleAction;
                    }

                    scene.add(character);
                    console.log('Personaje FBX cargado correctamente');
                    document.getElementById('loadingScreen').style.display = 'none';
                },
                (xhr) => {
                    const percentLoaded = 50 + (xhr.loaded / xhr.total) * 50;
                    document.getElementById('loadingBar').style.width = `${percentLoaded}%`;
                },
                (error) => {
                    console.error('Error al cargar el personaje:', error);
                    document.getElementById('loadingScreen').style.display = 'none';
                }
            );
        }

        // Funci√≥n para calcular distancia a Louise
        function getDistanceToLouise() {
            const louise = scene.getObjectByName('Louise');
            if (!louise || !controls.getObject()) return Infinity;

            const playerPosition = controls.getObject().position;
            const louisePosition = louise.position;

            return playerPosition.distanceTo(louisePosition);
        }

        function optimizeMaterial(material) {
            // Configuraci√≥n de materiales para mejor rendimiento
            if (material instanceof THREE.MeshStandardMaterial) {
                material.roughness = 0.8;
                material.metalness = 0.2;
            }
            material.side = THREE.FrontSide;
            material.flatShading = false;
            return material;
        }

        function setupLights() {
            scene.background = new THREE.Color(0xFFFFFF);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Luces optimizadas
            const ambientLight = new THREE.AmbientLight(0xFFFFFFF, .5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffe5b4, 0.3);
            directionalLight.position.set(3, 10, 5).normalize();
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffe5b4, 0.3, 50);
            pointLight.position.set(0, 1, 0);
            scene.add(pointLight);

            // Luces de rebote para paredes (posici√≥nalas seg√∫n tu escena)
            const wallLight1 = new THREE.DirectionalLight(0xFFF5E6, 0.4);
            wallLight1.position.set(-5, 2, 0); // Pared izquierda
            wallLight1.castShadow = false; // No necesitan sombras
            scene.add(wallLight1);

            const wallLight2 = new THREE.DirectionalLight(0xFFF5E6, 0.4);
            wallLight2.position.set(5, 2, 0); // Pared derecha
            scene.add(wallLight2);

            // Luz desde el techo (para iluminaci√≥n difusa)
            const ceilingLight = new THREE.RectAreaLight(0xFFFFFF, 0.3, 10, 10);
            ceilingLight.position.set(0, 5, 0);
            ceilingLight.rotation.x = Math.PI; // Apunta hacia abajo
            scene.add(ceilingLight);
        }

        function resetPlayerPosition() {
            if (controls && controls.getObject) {
                controls.getObject().position.copy(defaultPlayerPosition);
                velocity.set(0, 0, 0);
                canJump = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            needsShadowUpdate = true;
        }

        // Bucle de animaci√≥n optimizado
        function animate(currentTime) {
            stats.begin();
            rafId = requestAnimationFrame(animate);

            // Control de FPS
            const deltaTime = currentTime - lastRenderTime;
            const targetDelta = 1000 / targetFPS;

            if (deltaTime < targetDelta) {
                stats.end();
                return;
            }

            lastRenderTime = currentTime - (deltaTime % targetDelta);
            const clampedDeltaTime = Math.min(0.1, deltaTime / 1000);

            // Actualizar animaciones si el mixer existe
            if (mixer) {
                mixer.update(clampedDeltaTime);
            }

            if (controls && controls.isLocked) {
                updatePlayerMovement(clampedDeltaTime);
                applyGravity(clampedDeltaTime);
            }

            // Actualizar sombras solo cuando sea necesario
            if (needsShadowUpdate) {
                renderer.shadowMap.needsUpdate = true;
                needsShadowUpdate = false;
            }

            renderer.render(scene, camera);
            stats.end();
        }

        function updatePlayerMovement(deltaTime) {
            velocity.x *= FRICTION;
            velocity.z *= FRICTION;

            direction.set(0, 0, 0);
            if (moveForward) direction.z -= 1;
            if (moveBackward) direction.z += 1;
            if (moveLeft) direction.x -= 1;
            if (moveRight) direction.x += 1;

            if (direction.length() > 0) {
                direction.normalize();
                velocity.x += direction.x * MOVEMENT_SPEED * deltaTime * 10;
                velocity.z += direction.z * MOVEMENT_SPEED * deltaTime * 10;
                needsShadowUpdate = true;
            }

            controls.moveRight(-velocity.x * deltaTime);
            controls.moveForward(-velocity.z * deltaTime);
        }

        function applyGravity(deltaTime) {
            velocity.y -= GRAVITY * deltaTime * 10;
            controls.getObject().position.y += velocity.y * deltaTime;

            if (controls.getObject().position.y < defaultPlayerPosition.y) {
                controls.getObject().position.y = defaultPlayerPosition.y;
                velocity.y = 0;
                canJump = true;
                needsShadowUpdate = true;
            }
        }

        /***********************/
        /* SISTEMA DE DI√ÅLOGOS */
        /***********************/

        function setupDialogSystem() {
            // Evento para continuar
            document.getElementById('continueButton').addEventListener('click', () => {
                if (isDialogTyping) {
                    finishTyping();
                    return;
                }

                // Si hay m√°s partes de texto por mostrar
                if (currentTextPart < dialogTextParts.length - 1) {
                    currentTextPart++;
                    showTextPart(dialogTextParts[currentTextPart]);
                } else {
                    // Si no hay m√°s partes, mostrar opciones o cerrar di√°logo
                    if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                        showDialogOptions();
                    } else {
                        endDialog();
                    }
                }
            });
        }

        function setupInteraction() {
            // Verificar proximidad en el bucle de animaci√≥n
            function checkProximity() {
                const distance = getDistanceToLouise();

                if (distance <= DIALOG_TRIGGER_DISTANCE) {
                    if (!isNearLouise) {
                        isNearLouise = true;
                        // Mostrar indicador visual
                        document.getElementById('info').textContent = "Presiona E para hablar con Louise";
                    }
                } else {
                    if (isNearLouise) {
                        isNearLouise = false;
                        document.getElementById('info').textContent = "VR Study Room";

                        // Si el jugador se aleja durante el di√°logo
                        if (hasStartedDialog) {
                            endDialog();
                            hasStartedDialog = false;
                        }
                    }
                }
            }

            // A√±adir la verificaci√≥n al bucle de animaci√≥n
            const originalAnimate = animate;
            animate = function (currentTime) {
                originalAnimate(currentTime);
                if (controls.isLocked) {
                    checkProximity();
                }
            };
        }

        // Funci√≥n para iniciar un di√°logo
        function startDialog(dialogTree) {
            // Pausar controles
            controls.unlock();
            // Ocultar el bloqueador de instrucciones
            document.getElementById('blocker').style.display = 'none';

            // Mostrar contenedor de di√°logo
            const dialogContainer = document.getElementById('dialogContainer');
            dialogContainer.style.display = 'block';

            // Configurar di√°logo inicial
            currentDialogTree = dialogTree;
            showDialogNode('start');
        }

        // Funci√≥n para mostrar un nodo de di√°logo espec√≠fico
        function showDialogNode(nodeId) {
            const node = dialogs[nodeId];
            if (!node) return endDialog();

            currentDialogNode = node;
            document.getElementById('speakerName').textContent = node.character || 'LOUISE';

            // Cambiar a animaci√≥n de hablar
            if (mixer && talking1Action) {
                if (currentAction) currentAction.stop();
                talking1Action.reset().play();
                currentAction = talking1Action;
            }

            // Dividir el texto en partes
            splitDialogText(node.text);

            // Mostrar la primera parte del texto
            currentTextPart = 0;
            showTextPart(dialogTextParts[currentTextPart]);

            // Ocultar opciones inicialmente (se mostrar√°n al final del texto completo)
            document.getElementById('dialogOptions').innerHTML = '';
            document.getElementById('continueButton').style.display = 'none';
        }

        // Dividir el texto del di√°logo en partes m√°s peque√±as
        function splitDialogText(text) {
            const maxCharsPerPart = 200; // N√∫mero m√°ximo de caracteres por parte
            dialogTextParts = [];

            // Si el texto es m√°s corto que el m√°ximo, usarlo completo
            if (text.length <= maxCharsPerPart) {
                dialogTextParts.push(text);
                return;
            }

            // Dividir en p√°rrafos primero (basado en saltos de l√≠nea)
            const paragraphs = text.split('\n\n');

            for (const paragraph of paragraphs) {
                // Si el p√°rrafo es demasiado largo, dividirlo en oraciones
                if (paragraph.length > maxCharsPerPart) {
                    const sentences = paragraph.split(/(?<=[.!?])\s+/);
                    let currentPart = '';

                    for (const sentence of sentences) {
                        if (currentPart.length + sentence.length > maxCharsPerPart && currentPart.length > 0) {
                            dialogTextParts.push(currentPart.trim());
                            currentPart = sentence;
                        } else {
                            currentPart += (currentPart.length > 0 ? ' ' : '') + sentence;
                        }
                    }

                    if (currentPart.length > 0) {
                        dialogTextParts.push(currentPart.trim());
                    }
                } else {
                    dialogTextParts.push(paragraph);
                }
            }
        }

        // Mostrar una parte espec√≠fica del texto del di√°logo
      function showTextPart(part) {
    isDialogTyping = true;
    const dialogElement = document.getElementById('dialogText');
    dialogElement.textContent = '';
    const dialogSound = document.getElementById('dialogSound');
    
    // Configurar el sonido
    dialogSound.volume = 0.3; // Ajusta el volumen seg√∫n necesites
    let soundTimeout;

    // Iniciar animaci√≥n de hablar
    if (mixer && talking1Action) {
        if (currentAction) currentAction.stop();
        talking1Action.reset().play();
        currentAction = talking1Action;
    }

    let currentIndex = 0;
    const typingInterval = setInterval(() => {
        if (currentIndex < part.length) {
            dialogElement.textContent += part[currentIndex];
            currentIndex++;
            
            // Reproducir sonido solo para caracteres visibles (no espacios)
            if (part[currentIndex-1] !== ' ' && part[currentIndex-1] !== '\n') {
                // Detener cualquier sonido previo
                dialogSound.pause();
                dialogSound.currentTime = 0;
                
                // Reproducir el sonido
                dialogSound.play().catch(e => console.log("No se pudo reproducir sonido:", e));
            }
        } else {
            clearInterval(typingInterval);
            clearTimeout(soundTimeout);
            isDialogTyping = false;

            // Mostrar bot√≥n "Continuar" si hay m√°s partes
            if (currentTextPart < dialogTextParts.length - 1) {
                document.getElementById('continueButton').style.display = 'block';
                document.getElementById('continueButton').textContent = 'Continuar';
            }
            // Si es la √∫ltima parte, mostrar opciones o bot√≥n "Cerrar"
            else {
                if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                    showDialogOptions();
                } else {
                    document.getElementById('continueButton').style.display = 'block';
                    document.getElementById('continueButton').textContent = 'Cerrar';
                }

                // Volver a animaci√≥n Idle cuando termina de hablar
                if (mixer && idleAction) {
                    if (currentAction) currentAction.stop();
                    idleAction.reset().play();
                    currentAction = idleAction;
                }
            }
        }
    }, 30); // Velocidad de escritura (ajusta seg√∫n necesites)
}

        // Mostrar las opciones de di√°logo
        function showDialogOptions() {
            const optionsContainer = document.getElementById('dialogOptions');
            optionsContainer.innerHTML = '';

            if (currentDialogNode.options && currentDialogNode.options.length > 0) {
                currentDialogNode.options.forEach(option => {
                    const optionElement = document.createElement('div');
                    optionElement.className = 'dialog-option';
                    optionElement.textContent = option.text;
                    optionElement.addEventListener('click', () => {
                        showDialogNode(option.next);
                    });
                    optionsContainer.appendChild(optionElement);
                });
                document.getElementById('continueButton').style.display = 'none';
            }
        }

        // Saltar el efecto de escritura
function finishTyping() {
    clearTimeout(dialogTimeout);
    document.getElementById('dialogText').textContent = dialogTextParts[currentTextPart];
    isDialogTyping = false;
    
    // Detener el sonido
    const dialogSound = document.getElementById('dialogSound');
    dialogSound.pause();
    dialogSound.currentTime = 0;

    // Mostrar bot√≥n "Continuar" si hay m√°s partes
    if (currentTextPart < dialogTextParts.length - 1) {
        document.getElementById('continueButton').style.display = 'block';
        document.getElementById('continueButton').textContent = 'Continuar';
    }
    // Si es la √∫ltima parte, mostrar opciones o bot√≥n "Cerrar"
    else {
        if (currentDialogNode.options && currentDialogNode.options.length > 0) {
            showDialogOptions();
        } else {
            document.getElementById('continueButton').style.display = 'block';
            document.getElementById('continueButton').textContent = 'Cerrar';
        }
    }

    // Volver a animaci√≥n Idle cuando se fuerza el texto
    if (mixer && idleAction) {
        if (currentAction) currentAction.stop();
        idleAction.reset().play();
        currentAction = idleAction;
    }
}

        // Finalizar di√°logo
      function endDialog() {
    document.getElementById('dialogContainer').style.display = 'none';
    hasStartedDialog = false;
    
    // Detener el sonido
    const dialogSound = document.getElementById('dialogSound');
    dialogSound.pause();
    dialogSound.currentTime = 0;

    // Asegurarse de volver a la animaci√≥n Idle
    if (mixer && idleAction) {
        if (currentAction) currentAction.stop();
        idleAction.reset().play();
        currentAction = idleAction;
    }
    document.getElementById('blocker').style.display = 'none';
    // Intentar reactivar los controles
    try {
        controls.lock();
    } catch (e) {
        console.log("Los controles ya est√°n activos o no se pueden bloquear:", e);
    }

    if (getDistanceToLouise() > DIALOG_TRIGGER_DISTANCE) {
        controls.lock();
    }
}

        // Inicializaci√≥n controlada
        document.addEventListener('DOMContentLoaded', () => {
            init();
            animate(performance.now());
        });

        // Limpieza al salir
        window.addEventListener('beforeunload', () => {
            cancelAnimationFrame(rafId);
            if (renderer) renderer.dispose();
            if (stats) stats.dom.remove();
        });
    </script>
</body>

</html>